---
created_at: 2017-06-05
last_updated_at: 2017-06-29
title: "`new (void(*[i])())`と書けない理由"
---
<?xml version="1.0"?>
<i:article
  xmlns:i="https://ijkml.example.com/">

<i:head>
  <i:titlestring>`new (void(*[i])())`と書けない理由</i:titlestring>
</i:head>

<i:title>
  <i:snip language="cpp">new (void(*[i])())</i:snip>と書けない理由
</i:title>

<i:summary>
  <i:snip>i</i:snip>が定数式でないとき、
  <i:snip>new (void(*[i])())</i:snip>という式はC++として不適格(ill-formed)である。
  これは括弧で囲まれた型名はnew-type-idになれないことから従う。
  なお仮引数リストで終わる型名もnew-type-idになれないので、
  <i:snip>new void(*[i])()</i:snip>も不適格である。
</i:summary>

<i:body>
<i:section sid="intro">
<i:title>
  導入
</i:title>

<p>
ある日、あなたは返り値がvoid型である無引数関数へのポインター10個分のメモリーを動的に確保したくなった。
これは簡単だ。あなたは次のようなコードを書いた。これはC++として適格である。
</p>

<i:code language="cpp">void func() {
  void (**ppf)() = new (void(*[10])());
}
</i:code>

<p>
次の日、あなたは10個といわず非定数個分のメモリーを確保したくなった。
配列new式では要素数は定数でなくともよい。あなたは次のようなコードを書いた。
</p>

<i:code language="cpp">void func() {
  int i = 10;
  void (**ppf)() = new (void(*[i])());
}
</i:code>

<p>
しかしこれはC++として適格ではない。なぜか。
</p>
</i:section>

<i:section sid="new-expr-syntax">
<i:title>
  配列new式の構文
</i:title>
<p>
そもそもの話として、C++で配列型の変数を宣言するとき、その要素数は定数でなければならないのだった。
</p>

<i:code language="cpp">void func() {
  int a10i1[10];
  int i = 10;
  // int a10i2[i]; - error
}
</i:code>

<p>
それではnew式で要素数が定数でない配列を作れるのはなぜか。
それを考えるためnew-expressionの定義を見てみよう。
</p>

<i:code language="ebnf">new expression = [ "::" ], "new", [ new placement ], new type id, [ new initializer ] (* #1 *)
               | [ "::" ], "new", [ new placement ], "(", type id, ")", [ new initializer ]; (* #2 *)

new type id = type specifier seq, [ new declarator ];

type id = type specifier seq, [ abstract declarator ];

new declarator = ptr operator, [ new declarator ];
               | noptr new declarator

noptr new declarator = "[", expression, "]", [ attribute specifier seq ] (* #3 *)
                     | noptr new declarator, "[", constant expression, "]", [ attribute specifier seq ] (* #4 *);
</i:code>

<p>
new-expressionの規則は2つあり、
#1 は括弧で囲まれていない型名( new-type-id )、
#2 は括弧で囲まれた型名( <i:snip>(</i:snip>type-id<i:snip>)</i:snip> )を受け入れるために定義されている。
</p>

<i:code language="cpp">void func() {
  int *pi = new int;   // #1
  void (**ppf)() = new (void(*[10])()); // #2
}
</i:code>

<p>
規則 #3 が定数式とは限らない式を要素数にもつ配列を作ることを許している。
#3 で添字演算子の中身がexpressionなので、ここには非定数式を入れることができる。
</p>

<i:code language="cpp">void func() {
  int i = 10;
  new int[i]; // OK
  new int[i][30]; // OK
  // new int[30][i]; - error
  // 規則 #4 により、最も外側(最も左側)以外の添字演算 子の中身は定数式でなければならない
}
</i:code>

たとえば<i:snip>new int[i]</i:snip>という式は、

<pre>
new-expression : <i:snip>new int[i]</i:snip>
  [ "::" ]
  "new" : <i:snip>new</i:snip>
  [ new-placement ]
  new-type-id : <i:snip>int[i]</i:snip>
    type-specifier : <i:snip>int</i:snip>
    new-declarator : <i:snip>[i]</i:snip>
      noptr-new-declarator : <i:snip>[i]</i:snip>
      "[" : <i:snip>[</i:snip>
        expression : <i:snip>i</i:snip>
        "]" : <i:snip>]</i:snip>
  [ new-initializer ]
</pre>

という風に当てはめられる。だから適格。

<p>
逆に言うと #3 に当てはまらない場合は非定数要素数の配列を作ることができない。
後で示すが、実は最初の例はこのケースに該当する。
</p>
</i:section>

<i:section sid="new-type-id-syntax">
<i:title>new-type-idは括弧で囲まれていない</i:title>
<p>
さっきnew-type-idは括弧で囲まれていないと書いたが、それは本当だろうか。
今度はtype-specifier-seqの定義を見てみよう。
type-specifier-seqはnew-type-idの先頭の要素だ。
</p>

<i:code language="ebnf">type specifier seq = type specifier, [ attribute specifier seq ]
                   | type specifier, [ type specifier seq ];

type specifier = simple type specifier
               | elaborated type specifier
               | typename specifier
               | cv qualifier;
</i:code>

<p>
simple-type-specifierの先頭に来るのは
型名、
名前空間名、
<i:snip>decltype</i:snip>、
<i:snip>::</i:snip>
のいずれか<i:footnote fid="simple-type-specifier">
  これは嘘で本当はもっとあるが、いずれにせよ開き括弧は含まれていないのでとりあえず無視する
</i:footnote>。

elaborated-type-specifierの先頭に来るのは
<i:snip>class</i:snip>、
<i:snip>struct</i:snip>、
<i:snip>union</i:snip>、
<i:snip>enum</i:snip>
のいずれか。

typename-specifierの先頭に来るのは<i:snip>typename</i:snip>。

cv-qualifierはそのままCV修飾子。

というわけで type-specifierは開き括弧では始まらないというのは本当だった。
type-specifier-seqが開き括弧で始まらないので括弧で囲まれた式がnew-type-idになることもない。
これは考えてみると当然で、たとえば次のようなコードが書けないことからも分かる。
</p>

<i:code language="cpp">void func() {
  int i; // OK
  // (int) i; error

  new int; // OK
  // new ((int)); error
}
</i:code>
</i:section>

<i:section sid="main-section">
<i:title>
  <i:snip>new (void(*[i])())</i:snip>はnew-expressionではない
</i:title>
<p>
最初の例に出てきた<i:snip>new (void(*[i])())</i:snip>についてここで改めて考える。
これがnew-expressionだと仮定しよう。
</p>

<p>
まず、<i:snip>(void(*[i])())</i:snip>はnew-type-idではない。
type-specifier-seqは開き括弧では始まらないからだ。
ということは、
<i:snip>(void(*[i])())</i:snip>はtype-idを括弧で括ったものでなければならないが、
<i:snip>i</i:snip>は定数式でないので当然type-idにはなれない。
</p>

<p>
まとめると、<i:snip>new (void(*[i])())</i:snip>はnew-expressionではない。
もしそうなら<i:snip>(void(*[i])())</i:snip>はnew-type-idである、
または <i:snip>void(*[i])()</i:snip>はtype-idである、
のいずれかが成り立たなければならないが、
new-type-idは括弧で囲まれることはないし、
<i:snip>i</i:snip>は定数式ではないからだ。

というわけではじめに載せたコードは正しくない。

</p>

</i:section>

<i:section sid="solution">
<i:title>解決策</i:title>

  <i:section sid="solution-typedef">
    <i:title>方法1: typedef名を使う</i:title>
      <i:code language="cpp">void func() {
  int i = 10;
  using F = void(*)();
  void (**ppf)() = new F[i];
}
      </i:code>
  </i:section>

  <i:section sid="solution-noparenthesis">
    <i:title>方法2(間違い): 括弧で囲まない</i:title>
    <p>
      括弧で囲むとnew-type-idでなくなるならば、括弧で囲まなければ大丈夫そうである。
    </p>
      <i:code language="cpp">void func() {
  int i = 10;
  void (**ppf)() = new void(*[i])();
}
</i:code>

    <p>
      ところがこれは正しくない。
      <i:snip>void(*[i])()</i:snip>はnew-type-idではないからだ。
      これは、new-type-idはtype-idとは違って関数の宣言子を含むことができないという事情による。
    </p>
    <i:code language="ebnf">new type id = type specifier seq, [ new declarator ];

type id = type specifier seq, [ abstract declarator ];

new declarator = ptr operator, [ new declarator ];
               | noptr new declarator;

abstract declarator = ptr abstract declarator
                    | [ noptr abstract declarator ], parameters and qualifiers (* #1 *)
                    | abstract pack declarator;

parameters and qualifiers = "(", parameter declaration clause, ")", [ cv qualifier seq ],
                            [ ref qualifier ], [ noexpect qualifier ], [ attribute specifier seq ];

</i:code>
    <p>
      noptr-new-declaratorはnoptr-abstract-declaratorとは異なり、parameters-and-qualifiers(#1)をもつことができない。
      このため<i:snip>void (*[i])()</i:snip>はnew-type-idになれない。引数リストをもつからだ。
      <i:snip>i</i:snip>が定数式でないのでtype-idになることもできない。
      このあたりの話は<i:cpp-std section="expr.new" paragraph="4"/>にも書いてある。
    </p>
  </i:section>

  <i:section sid="solution-std-vector">
    <i:title>方法3: <i:snip>std::vector</i:snip>を使う</i:title>
    <i:code language="cpp">void func() {
  int i = 10;
  std::vector&lt;void(*)()&gt; vf(i);
}
</i:code>
  </i:section>

  <i:section sid="solution-std-function">
    <i:title>方法4: <i:snip>std::function</i:snip>を使う</i:title>
    <i:code language="cpp">void func() {
  int i = 10;
  std::function&lt;void()&gt; *pf = new std::function&lt;void()&gt;[i];
</i:code>
  </i:section>

<p>
個人的には非定数要素数配列の要素数を添字演算子の中に入れる記法は仕様を無意味に複雑にするだけで良くなかったと思う。
<i:snip>new{i} int</i:snip>みたいにすれば多少マシになったのではないか。
</p>
</i:body>

</i:article>
