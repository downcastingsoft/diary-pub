---
created_at: 2017-06-05
last_updated_at: 2017-06-29
title: "`new (void(*[i])())`と書けない理由"
---
<?xml version="1.0"?>
<i:article
  xmlns:i="https://ijkml.example.com/">

<i:head>
  <i:titlestring>`new (void(*[i])())`と書けない理由</i:titlestring>
</i:head>

<i:title>
  <i:snip language="cpp">new (void(*[i])())</i:snip>と書けない理由
</i:title>

<i:summary>
  <i:snip>i</i:snip>が定数式でないとき、
  <i:snip>new (void(*[i])())</i:snip>という式は不適格(ill-formed)である。
  <i:snip>new int[i]</i:snip>や<i:snip>new (void(*[10])())</i:snip>が
  適格であることを考えるとこれは驚くべきことである。
  この記事では、C++におけるnew-expressionの定義からこの式が適格でないことを示す。
</i:summary>

<i:body>
<i:section sid="intro">
<i:title>
  導入
</i:title>

<p>
ある日、あなたは返り値がvoid型である無引数関数へのポインター10個分のメモリーを動的に確保したくなった。
これは簡単だ。あなたは次のようなコードを書いた。これはC++として適格である。
</p>

<i:code language="cpp">void func() {
  void (**ppf)() = new (void(*[10])());
}
</i:code>

<p>
次の日、あなたは10個といわず非定数個分のメモリーを確保したくなった。
配列new式では要素数は定数でなくともよい。あなたは次のようなコードを書いた。
</p>

<i:code language="cpp">void func() {
  int i = 10;
  void (**ppf)() = new (void(*[i])());
}
</i:code>

<p>
しかしこれはC++として適格ではない。なぜか。
</p>
</i:section>

<i:section sid="new-expr-syntax">
<i:title>
  配列new式の構文
</i:title>
<p>
そもそもの話として、C++で配列型の変数を宣言するとき、その要素数は定数でなければならないのだった。
</p>

<i:code language="cpp">void func() {
  int a10i1[10];
  int i = 10;
  // int a10i2[i]; - error
}
</i:code>

<p>
それではnew式で要素数が定数でない配列を作れるのはなぜか。
それを考えるためnew-expressionの定義を見てみよう。
</p>

<i:code language="ebnf">new expression = [ "::" ], "new", [ new placement ], new type id, [ new initializer ] (* #1 *)
               | [ "::" ], "new", [ new placement ], "(", type id, ")", [ new initializer ]; (* #2 *)

new type id = type specifier seq, [ new declarator ];

type id = type specifier seq, [ abstract declarator ];

new declarator = ptr operator, [ new declarator ];
               | noptr new declarator

noptr new declarator = "[", expression, "]", [ attribute specifier seq ] (* #3 *)
                     | noptr new declarator, "[", constant expression, "]", [ attribute specifier seq ] (* #4 *);
</i:code>

<p>
new-expression の規則は2つあり、 #1 は括弧で囲まれていない型(new-type-id)、 #2 は括弧で囲まれた型を受け入れるために定義されている。
</p>

<i:code language="cpp">void func() {
  int *pi = new int;   // #1
  void (**ppf)() = new (void(*[10])()); // #2
}
</i:code>

<p>
規則 #3 が定数式とは限らない式を要素数にもつ配列を作ることを許している。
#3 で添字演算子の中身が expression なので、ここには非定数式を入れることができる。
</p>

<i:code language="cpp">void func() {
  int i = 10;
  new int[i]; // OK
  new int[i][30]; // OK
  // new int[30][i]; - error
  // 規則 #4 により、最も外側(最も左側)以外の添字演算子の中身は定数式でなければならない
}
</i:code>

たとえば <i:snip>new int[i]</i:snip> という式は、

<pre>
new-expression: <i:snip>new int[i]</i:snip>
  [ "::" ]
  "new" : <i:snip>new</i:snip>
  [ new-placement ]
  new-type-id : <i:snip>int[i]</i:snip>
    type-specifier: <i:snip>int</i:snip>
    new-declarator: <i:snip>[i]</i:snip>
      noptr-new-declarator: <i:snip>[i]</i:snip>
      "[" : <i:snip>[</i:snip>
        expression : <i:snip>i</i:snip>
        "]" : <i:snip>]</i:snip>
  [ new-initializer ]
</pre>

という風に当てはめられる。だから適格。

<p>
逆に言うと #3 に当てはまらない場合は非定数要素数の配列を作ることができない。
後で示すが、実は最初の例はこのケースに該当する。
</p>
</i:section>

<i:section sid="new-type-id-syntax">
<i:title>new-type-idについてもう少し詳しく見る</i:title>
<p>
さっき new-type-id は括弧で囲まれていないと書いたが、それは本当だろうか。
今度は type-specifier-seq の定義を見てみよう。
type-specifier-seq は new-type-id の先頭の要素だ。
</p>

<i:code language="ebnf">type specifier seq = type specifier, [ attribute specifier seq ]
                   | type specifier, [ type specifier seq ];

type specifier = simple type specifier
               | elaborated type specifier
               | typename specifier
               | cv qualifier;
</i:code>

<p>
simple-type-specifier の先頭に来るのは
型名、
名前空間名、
<i:snip>decltype</i:snip>、
<i:snip>::</i:snip>
のいずれか
<i:footnote fid="simple-type-specifier">
  これは嘘で本当はもっとあるが、いずれにせよ開き括弧は含まれていないのでとりあえず無視する
</i:footnote>。

elaborated-type-specifier の先頭に来るのは
<i:snip>class</i:snip>、
<i:snip>struct</i:snip>、
<i:snip>union</i:snip>、
<i:snip>enum</i:snip>
のいずれか。

typename-specifier の先頭に来るのは <i:snip>typename</i:snip>。

cv-qualifier はそのままCV修飾子。

というわけで type-specifier は開き括弧では始まらないというのは本当だった。
たとえば次のようなコードは書けない。
</p>

<i:code language="cpp">void func() {
  int i; // OK
  // (int) i; error

  new int; // OK
  // new ((int)); error
}
</i:code>
</i:section>

<i:section sid="main-section">
<i:title>
  <i:snip>new (void(*[i])())</i:snip>はnew-expressionではない
</i:title>
<p>
最初の例に出てきた<i:snip>new (void(*[i])())</i:snip>についてここで改めて考える。これがnew-expressionだと仮定しよう。
</p>

<p>
まず、<i:snip>(void(*[i])())</i:snip>はnew-type-idではない。
type-specifier-seqは開き括弧では始まらないからだ。
ということは、
<i:snip>(void(*[i])())</i:snip>はtype-idを括弧で括ったものであり、
<i:snip>void(*[i])()</i:snip>はtype-specifierでなければならない。

(無)
(無)

</p>

<p>
まとめると、<i:snip>new (void(*[i])())</i:snip>はnew-expressionではない。
もしそうなら<i:snip>(void(*[i])())</i:snip>はnew-type-idである、
または<i:snip>void(*[i])()</i:snip>はtype-idである、
のいずれかが成り立たなければならないが、
new-type-idは括弧で始まることはないし、
<i:snip>i</i:snip>はconstant-expressionではないからだ。

というわけではじめに載せたコードは正しくない。

</p>

</i:section>

<i:section sid="solution">
<i:title>解決策</i:title>

  <i:section sid="solution-typedef">
    <i:title>方法1: typedef名を使う</i:title>
      <i:code language="cpp">void func() {
  int i = 10;
  using F = void(*)();
  void (**ppf)() = new F[i];
}
      </i:code>
  </i:section>

  <i:section sid="solution-noparenthesis">
    <i:title>方法2(間違い): 括弧で囲まない</i:title>
    <p>
      括弧で囲むとnew-type-idでなくなるならば、括弧で囲まなければ大丈夫そうである。
    </p>
      <i:code language="cpp">void func() {
  int i = 10;
  void (**ppf)() = new void(*[i])();
}
</i:code>

    <p>
      ところがこれは正しくない。
      <i:snip>void(*[i])()</i:snip>はnew-type-idではないからだ。
      これは、new-type-idはtype-idとは違って関数の宣言子を含むことができないという事情による。
    </p>
    <i:code language="ebnf">new type id = type specifier seq, [ new declarator ];

type id = type specifier seq, [ abstract declarator ];

new declarator = ptr operator, [ new declarator ];
               | noptr new declarator;

abstract declarator = ptr abstract declarator
                    | [ noptr abstract declarator ], parameters and qualifiers (* #1 *)
                    | abstract pack declarator;

parameters and qualifiers = "(", parameter declaration clause, ")", [ cv qualifier seq ],
                            [ ref qualifier ], [ noexpect qualifier ], [ attribute specifier seq ];

</i:code>
    <p>
      noptr-new-declaratorはnoptr-abstract-declaratorとは異なり、引数リスト(#1)をもつことができない。
      このため<i:snip>void (*[i])()</i:snip>はnew-type-idになれない。引数リストをもつからだ。
      <i:snip>i</i:snip>が定数式でないのでtype-idになることもできない。
      このあたりの話は<i:cpp-std section="expr.new" paragraph="4"/>にも書いてある。
    </p>
</i:section>

</i:body>

</i:article>
