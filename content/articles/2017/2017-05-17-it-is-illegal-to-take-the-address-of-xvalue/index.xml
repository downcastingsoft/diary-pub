---
created_at: 2017-05-17
last_updated_at: 2017-06-29
title: "xvalueにaddress-of演算子は適用できない"
---
<?xml version="1.0"?>
<i:article xmlns:i="https://ijkml.example.com/">

<i:head>
</i:head>

<i:title>
  xvalueにaddress-of演算子は適用できない
</i:title>

<i:body>
  <p>
    タイトルの通り。たとえばこういうことは(当然だが)できない。
  </p>
  <i:code lang="cpp">#include &lt;utility&gt;

int main() {
  int i = 0;
  int *pi = &amp;(std::move(i));
  return 0;
}
</i:code>

  <p>
    <i:cpp-std section="expr.unary.op" paragraph="3" />において
  </p>
  <i:quote>
    <p>
      The result of the unary &amp; operator is a pointer to its operand.
      The operand shall be an lvalue or a qualified-id.
    </p>
    <p>
      &amp; 演算の結果は被演算子へのポインターである。被演算子はlvalueかqualified-idでなければならない。
    </p>
  </i:quote>
  <p>
    と定められているからだ。
    こうなっている理由を考えたけどいくつかある。
  </p>

  <i:section sid="apply-amp-to-prvalue">
    <i:title>prvalueに&amp;演算子を適用できるようになってしまう</i:title>
    <p>
      glvalueが求められる文脈にprvalueが出現するとtemporary materialization conversionが適用されてxvalueになる。
      だからたとえば次のようなコードが可能になってしまう。
    </p>

    <i:code language="cpp">int main() {
  int *pi = &amp;1;
  return 0;
}
</i:code>

    <p>
      さすがにこれは気持ち悪い。
      Conversion sequenceがtemporary materialization conversionを含んでいたらill-formedとする(<i:cpp-std section="dcl.init.ref" paragraph="5"/>みたいに)みたいな定め方もできそうだがダルい。
    </p>
  </i:section>
  <i:section sid="star-op">
    <i:title>*演算子との整合性</i:title>
    <p>
      *演算の結果はlvalueである(<i:cpp-std section="expr.unary.op" paragraph="3" />)ので、もしもxvalueに&amp;演算子が適用できるとすると、
      合法的にxvalueを(そしてprvalueを)lvalueに変換することができてしまう。
      たとえば次のように。
    </p>
    <i:code language="cpp">int main() {
  int i = 0;
  // *(&amp;(std::move(i)));
  return 0;
}
</i:code>

  </i:section>

</i:body>

</i:article>
