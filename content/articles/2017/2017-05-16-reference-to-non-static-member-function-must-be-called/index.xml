---
created_at: 2017-05-16
last_updated_at: 2017-07-22
title: "非staticメンバー関数は呼ぶことしかできない([expr.ref]/4.3.2)"
---
<?xml version="1.0"?>
<i:article xmlns:i="https://ijkml.example.com/">

<i:head>
</i:head>

<i:title>
非staticメンバー関数は呼ぶことしかできない([expr.ref]/4.3.2)
</i:title>

<i:summary>
C++では、クラス型オブジェクトの非staticメンバー関数への参照 <i:snip language="cpp">a.func</i:snip>
はメンバー関数呼び出し式の第一オペランドとしてのみ出現可能(<i:snip language="cpp">a.func()</i:snip>)であり、
代入式の右辺にしたりアドレスを取ったりすることはできない。
これは<i:cpp-std section="expr.ref" paragraph="4.3.2" />で定められている。
この記事は規格を読んだ後書き直した。
</i:summary>

<i:body>
<p>
概要の通り。例：
</p>

<i:code language="cpp">class A {
  public:
  void func() { }
};

int main() {
  A a;
  a.func;   // error
  return 0;
}
</i:code>

<p>
Clangのエラーメッセージ
</p>

<i:code lang="terminal">2017-05-14-memcall.cpp:8:5: error: reference to non-static member function must be called; did you mean to call it with no arguments?
  a.func;
  ~~^~~~
        ()
1 error generated.
</i:code>

<p>
  関数ポインターにdecayすることができないのでこのような仕様になっているのだろう。
  非staticメンバー関数への参照はオブジェクトとメンバー関数と2つの情報をもつが、
  非staticメンバー関数の実体は普通ひとつなので、関数ポインターにするとオブジェクトの情報が失われてしまうから。
</p>

<i:section sid="solution">
<i:title>解決策</i:title>
<p>
  ラムダにする。
</p>
<i:code lang="cpp">#include &lt;iostream&gt;

class B {
  public:
  const int func(int x) { return x * x; }
};

int main() {
  B b;
  const auto f = [&amp;b](int x) { return b.func(x); };
  std::cout &lt;&lt; f(5) &lt;&lt; std::endl;
  return 0;
}
</i:code>
</i:section>

</i:body>

</i:article>
2017-05-16-reference-to-non-static-member
